# QuickSort Implementation in C++

## Problem Statement
The goal of this code is to sort a list of integers using the QuickSort algorithm. QuickSort is a popular, efficient, and in-place sorting algorithm that uses a divide-and-conquer strategy to arrange elements in ascending order.

## Code Explanation
The code consists of the following key components:

### 1. Partition Function
- **Purpose:**  
  Rearranges the elements in the array so that every element less than the pivot comes before it, and every element greater than or equal to the pivot comes after it.
  
- **Parameters:**  
  - `vector<int>& arr`: The array (vector) of integers to sort.  
  - `int st`: The starting index of the sub-array.  
  - `int end`: The ending index of the sub-array. The element at `arr[end]` is chosen as the pivot.

- **Logic:**  
  - An index `idx` is initialized to `st - 1` to mark the end of the section of elements that are less than the pivot.
  - The loop iterates from `st` to `end - 1`, comparing each element with the pivot.
  - If an element is found to be less than the pivot, `idx` is incremented and that element is swapped with the element at the new `idx`.
  - Finally, the pivot is swapped into its correct position (i.e., `idx + 1`), and the new index of the pivot is returned.

### 2. QuickSort Function
- **Purpose:**  
  Sorts the array recursively using the partitioning process.
  
- **Parameters:**  
  - `vector<int>& arr`: The array to sort.  
  - `int st`: The starting index of the current sub-array.  
  - `int end`: The ending index of the current sub-array.

- **Logic:**  
  - The function checks if the current sub-array has one or no elements (base case). If so, it returns.
  - It calls the `partition` function to obtain the partition index (`partitionidx`), where the pivot element is in its correct sorted position.
  - The function then recursively sorts the two sub-arrays: one to the left of the pivot and one to the right of the pivot.

### 3. Print Function
- **Purpose:**  
  Outputs the elements of the array to the console.
  
- **Logic:**  
  Iterates over each element in the array and prints it, separated by spaces.

### 4. Main Function
- **Purpose:**  
  Serves as the entry point of the program.
  
- **Logic:**  
  - A vector `v` containing unsorted integers is defined.
  - The `quicksort` function is called with the starting index `0` and the ending index `v.size() - 1`.
  - The sorted array is then printed to the console using the `print` function.

## Approach and Logic
- **Divide and Conquer:**  
  The QuickSort algorithm divides the problem into smaller sub-problems by selecting a pivot element and partitioning the array around it. This means that after partitioning, the pivot element is in its correct position, and the same process is applied recursively to the left and right sub-arrays.

- **Partitioning:**  
  The partition function is central to the algorithm. By comparing each element to the pivot and swapping when necessary, it ensures that elements less than the pivot are moved to its left, and those greater are moved to its right.

- **Recursion:**  
  The algorithm employs recursion to sort the sub-arrays generated by partitioning. The base case of the recursion is reached when the sub-array has one or zero elements.

- **In-place Sorting:**  
  QuickSort sorts the array in-place, meaning it does not require additional memory proportional to the input size aside from the recursion stack.

## Time and Space Complexity
- **Time Complexity:**  
  - **Average and Best Case:** O(n log n), where n is the number of elements.  
  - **Worst Case:** O(nÂ²), which can occur when the smallest or largest element is consistently chosen as the pivot (e.g., when the array is already sorted in a particular order).  
  Note: In practical scenarios, especially with random or well-distributed inputs, the average-case performance is more representative.

- **Space Complexity:**  
  - **In-Place Sorting:** The algorithm uses O(log n) space on average due to the recursion stack.  
  - **Worst Case:** In the worst-case scenario (unbalanced partitions), the recursion depth could be O(n).

## Conclusion
This C++ code demonstrates an implementation of the QuickSort algorithm, a widely used sorting method that efficiently handles average-case scenarios with O(n log n) time complexity. By partitioning the array around a pivot and recursively sorting the sub-arrays, the algorithm ensures that the elements are sorted in-place, making it both space-efficient and practical for a wide range of applications.